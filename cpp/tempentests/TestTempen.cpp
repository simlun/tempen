#include "catch.h"


class Task {
public:
    Task * work() {
        doWork();
        return nextTask;
    }

    Task * setNext(Task * task) {
        nextTask = task;
        return nextTask;
    }

protected:
    virtual void doWork() = 0;

private:
    Task * nextTask = nullptr;
};


class Clerk {
public:
    void work() {
        if (currentTask != nullptr) {
            Task * nextTask = currentTask->work();
            giveTask(nextTask);
        }
    }

    void giveTask(Task *task) {
        currentTask = task;
    }
private:
    Task * currentTask = nullptr;
};


class CountUpFromZero : public Task {
public:
    int workCount = 0;

protected:
    void doWork() override {
        workCount++;
    }
};


SCENARIO("A Clerk has a workflow of connected Tasks") {
    Clerk alice;

    GIVEN("A Clerk without tasks") {
        WHEN("working") {
            alice.work();
            THEN("nothing happens") {
                REQUIRE(true);
            }
        }
    }

    GIVEN("A Clerk and one task") {
        CountUpFromZero task;
        REQUIRE(task.workCount == 0);
        alice.giveTask(&task);

        WHEN("working once") {
            alice.work();
            THEN("the task is worked on once") {
                REQUIRE(task.workCount == 1);
            }
        }

        WHEN("working twice") {
            alice.work();
            alice.work();
            THEN("the task is still only worked on once") {
                REQUIRE(task.workCount == 1);
            }
        }

        WHEN("the task has itself as the next task") {
            task.setNext(&task);
            THEN("working multiple times will perform work multiple times") {
                alice.work();
                alice.work();
                alice.work();
                REQUIRE(task.workCount == 3);
            }
        }
    }

    GIVEN("A Clerk and two tasks") {
        CountUpFromZero firstTask;
        CountUpFromZero secondTask;
        alice.giveTask(&firstTask);

        WHEN("chaining the tasks") {
            firstTask.setNext(&secondTask)->setNext(&firstTask);
            THEN("working three times will trigger first task twice and second task once") {
                alice.work();
                REQUIRE(firstTask.workCount == 1);
                REQUIRE(secondTask.workCount == 0);
                alice.work();
                REQUIRE(firstTask.workCount == 1);
                REQUIRE(secondTask.workCount == 1);
                alice.work();
                REQUIRE(firstTask.workCount == 2);
                REQUIRE(secondTask.workCount == 1);
            }
        }
    }
}